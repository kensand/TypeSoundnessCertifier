ocamlfind ocamlc -package batteries -linkpkg aux.ml type_system.ml terms.ml values.ml nonvalues.ml eitherLemma.ml canonicalForms.ml contextualRules.ml progress.ml preservationTests.ml preservation.ml generateLambdaProlog.ml calculi.ml

#use "topfind";;
#require "batteries";;
open Batteries;;
#load "unix.cma";;

#load  "aux.cmo";;
#load "type_system.cmo" ;;
#load  "terms.cmo";;
#load  "values.cmo";;
#load  "nonvalues.cmo";;
#load  "eitherLemma.cmo";;
#load  "canonicalForms.cmo";;
#load  "contextualRules.cmo";;
#load  "progress.cmo";;
#load  "preservationTests.cmo";;
#load  "preservation.cmo";;
#load  "generateLambdaProlog.cmo";;
#load  "calculi.cmo";;

open Aux;;
open Type_system;;
open Terms;;
open Values;;
open Nonvalues;;
open EitherLemma;;
open CanonicalForms;;
open ContextualRules;;
open Progress;;
open PreservationTests;;
open Preservation;;
open GenerateLambdaProlog;;
open Calculi;;

let ts = generateNonValues (generateTermPred (generateValues systemF));;
let ts = addContextualRules ts;;
print_string (generateModule ts);;
print_string (generateSignature ts);;
print_string (generateEitherLemma ts);;
print_string (generateCanonicalFormsLemma ts);;
print_string (generateProgressLemmas ts);;
print_string (generateProgressTheorem ts);;
print_string (generatePreservationTheorem ts);;
print_string (generateTestModule ts);;
print_string (runPreservationTests ts);;

#load  "aux.cmo";;
# load "type_system.cmo" ;;
# load  "terms.cmo";;
# load  "values.cmo";;
# load  "nonvalues.cmo";;
# load  "eitherLemma.cmo";;
# load  "canonicalForms.cmo";;
# load  "contextualRules.cmo";;
# load  "progress.cmo";;
# load  "generateLambdaProlog.cmo";;
#load  "preservationTests.cmo";;
# load  "preservation.cmo";;
# load  "calculi.cmo";;



let firstConstructor = getConstructor term in 
         let abstractionsNum = getNumberOfAbstractionsByConstr nestedConstructor signatureTerms in 
         let abstractions = List.take abstractionsNum (getArgumentsOfConstructor term) in 
         let getAssociations = fun abstraction -> (abstraction, getAppliedTermsFor abstraction conclusionTerm) in
         let firstAbstractions = List.map getAssociations abstractions in
         let nestedTerm = 
         let nestedConstructor = getConstructor term in 
         let abstractionsNum = getNumberOfAbstractionsByConstr nestedConstructor signatureTerms in 
         let abstractions = List.take abstractionsNum (getArgumentsOfConstructor term) in 
         let getAssociations = fun abstraction -> (abstraction, getAppliedTermsFor abstraction conclusionTerm) in
          firstAbstractions @ (List.map getAssociations abstractions)


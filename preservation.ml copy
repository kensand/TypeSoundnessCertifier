
open Type_system
open Batteries
open Terms

let maybeSubstitutionLemmaBeforeSearch signatureTerms rule = match rule with Rule(name,premises,conclusion) ->
         let nestedTerm = (List.hd (getArgumentsOfConstructor (getTermInInput conclusion))) in 
         let nestedConstructor = getConstructor nestedTerm in 
         let abstractionsNum = getNumberOfAbstractionsByConstr nestedConstructor signatureTerms in 
         let abstractions = List.take abstractionsNum (getArgumentsOfConstructor nestedTerm) in 
         let getAssociations = fun abstraction -> getAppliedTermsFor abstraction (getTermInOutput conclusion) in
         let associations =  List.map getAssociations abstractions in
         let singleAppealToSubstitutionLemma = fun i1 -> fun i2 -> fun arg -> let iOfSubst = i1+1 in let iOfTypeOf = i2+1 in "Subst: inst Subst" ^ (string_of_int iOfSubst) ^ " with n1 = " ^ toString arg ^ ". cut Subst with TypeOf" ^ (string_of_int iOfTypeOf) ^ "." in 
         let appealToSubstitutionLemma = fun i -> fun args -> String.concat " " (List.mapi (singleAppealToSubstitutionLemma i) args) in 
         let substHyp = String.concat "\n" (List.mapi appealToSubstitutionLemma associations) in 
           substHyp ^ " search."

let generatePreservationTheorem ts = match ts with TypeSystem(signatureTypes,signatureTerms,rules) ->
         let onlyConstructors = getConstructorFromTypeSignature signatureTypes in
         let onlyDeConstructors = getDeConstructorFromTypeSignature signatureTypes in
         let reductionRules = List.take (List.length onlyConstructors) (List.filter onlyStepRules rules) in 
         let contextRules = List.drop (List.length onlyConstructors) (List.filter onlyStepRules rules) in 
         let theorem = "Theorem preservation : forall E E' T, {step E E'} -> {typeOf E T} -> {typeOf E' T}. induction on 1. intros Main TypeOf. Step : case Main.\n" in
         let subProofReduction = (fun rule -> "TypeOf : case TypeOf. Subst1 : case TypeOf. " ^ (maybeSubstitutionLemmaBeforeSearch signatureTerms rule) ^ "\n") in
         let subProofContextual = (fun rule -> match rule with Rule(name,premises,conclusion) -> let hypByArgIndex = "TypeOf" ^ (String.right name 1) in "TypeOf1 : case TypeOf. apply IH to Step " ^ hypByArgIndex ^ ". search.\n") in
         let proofReductions = String.concat "" (List.map subProofReduction reductionRules) in
         let proofContextual = String.concat "" (List.map subProofContextual contextRules) in
            theorem ^ proofReductions ^ proofContextual
         

Specification "lambdafull_cbv".



Theorem  canonical_form_bool : forall E, {typeOf E (bool )} -> {value E} -> E = (ff ) \/ E = (tt ).
intros Main Value. case Main.
 case Value. search.
 case Value. search.

 case Value. case Value. case Value. case Value. case Value. case Value.
 case Value. case Value.



Theorem  canonical_form_list : forall E T1, {typeOf E (list T1)} -> {value E} -> (exists Arg1 Arg2, E = (cons Arg1 Arg2) /\ {value Arg1} /\ {value Arg2}) \/ E = (emptyList ).
intros Main Value. case Main.
 case Value. search.
 case Value. search.

 case Value. case Value. case Value. case Value. case Value. case Value. case Value.
 case Value. case Value.



Theorem  canonical_form_mu : forall E U1, {typeOf E (mu U1)} -> {value E} -> (exists Arg1 Arg2, E = (fold Arg1 Arg2) /\ {value Arg1}).
intros Main Value. case Main.
 case Value. search.

 case Value. case Value. case Value. case Value. case Value. case Value.
 case Value. case Value.



Theorem  canonical_form_arrow : forall E T1 T2, {typeOf E (arrow T1 T2)} -> {value E} -> (exists Arg1, E = (abs Arg1)).
intros Main Value. case Main.
 case Value. search.

 case Value. case Value. case Value. case Value. case Value. case Value.
 case Value. case Value.



Theorem  canonical_form_excType : forall E, {typeOf E (excType )} -> {value E} -> E = (excValue ).
intros Main Value. case Main.
 case Value. search.

 case Value. case Value. case Value. case Value. case Value. case Value.
 case Value. case Value.





Define progresses : term -> prop by
	 progresses E := {value E} ;
	 progresses E := {error E} ;
	 progresses E := exists E', {step E E'}.

Theorem progress_ff : forall  T, {typeOf ((ff )) T} -> progresses ((ff )).
 search.



Theorem progress_tt : forall  T, {typeOf ((tt )) T} -> progresses ((tt )).
 search.



Theorem progress_if : forall E1 E2 E3 T, {typeOf ((if E1 E2 E3)) T} -> progresses E1 -> progresses ((if E1 E2 E3)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 Canonical : apply canonical_form_bool to TypeOfE1 ProgressClause. case Canonical. search. search. search. search.



Theorem progress_cons : forall E1 E2 T, {typeOf ((cons E1 E2)) T} -> progresses E1 -> progresses E2 -> progresses ((cons E1 E2)).
intros Main PrgsE1 PrgsE2. TypeOfE1 : case Main. ProgressClause : case PrgsE1. case PrgsE2.
 search. search. search. search. search.



Theorem progress_emptyList : forall  T, {typeOf ((emptyList )) T} -> progresses ((emptyList )).
 search.



Theorem progress_tail : forall E1 T, {typeOf ((tail E1)) T} -> progresses E1 -> progresses ((tail E1)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 Canonical : apply canonical_form_list to TypeOfE1 ProgressClause. case Canonical. search. search. search. search.



Theorem progress_head : forall E1 T, {typeOf ((head E1)) T} -> progresses E1 -> progresses ((head E1)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 Canonical : apply canonical_form_list to TypeOfE1 ProgressClause. case Canonical. search. search. search. search.



Theorem progress_fold : forall E1 U2 T, {typeOf ((fold E1 U2)) T} -> progresses E1 -> progresses ((fold E1 U2)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 search. search. search.



Theorem progress_unfold : forall E1 T, {typeOf ((unfold E1)) T} -> progresses E1 -> progresses ((unfold E1)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 Canonical : apply canonical_form_mu to TypeOfE1 ProgressClause.  search. search. search.



Theorem progress_abs : forall R1 T, {typeOf ((abs R1)) T} -> progresses ((abs R1)).
 search.



Theorem progress_app : forall E1 E2 T, {typeOf ((app E1 E2)) T} -> progresses E1 -> progresses E2 -> progresses ((app E1 E2)).
intros Main PrgsE1 PrgsE2. TypeOfE1 : case Main. ProgressClause : case PrgsE1. case PrgsE2.
 Canonical : apply canonical_form_arrow to TypeOfE1 ProgressClause.  search. search. search. search. search.



Theorem progress_excValue : forall  T, {typeOf ((excValue )) T} -> progresses ((excValue )).
 search.



Theorem progress_letrec : forall R1 R2 T, {typeOf ((letrec R1 R2)) T} -> progresses ((letrec R1 R2)).
 search.



Theorem progress_fix : forall E1 T, {typeOf ((fix E1)) T} -> progresses E1 -> progresses ((fix E1)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 search. search. search.



Theorem progress_try : forall E1 E2 T, {typeOf ((try E1 E2)) T} -> progresses E1 -> progresses ((try E1 E2)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 search. case ProgressClause. search. search.



Theorem progress_raise : forall E1 T, {typeOf ((raise E1)) T} -> progresses E1 -> progresses ((raise E1)).
intros Main PrgsE1. TypeOfE1 : case Main. ProgressClause : case PrgsE1.
 search. search. search.





Theorem progress : forall E T, {typeOf E T} -> progresses E. 
induction on 1. intros Main. TypeOfE1 : case Main.
 backchain progress_ff.
  backchain progress_tt.
 apply IH to TypeOfE1. apply IH to TypeOfE2. backchain progress_cons.
  backchain progress_emptyList.
 apply IH to TypeOfE1. backchain progress_fold.
  backchain progress_abs.
  backchain progress_excValue.

 apply IH to TypeOfE1. backchain progress_if.
 apply IH to TypeOfE1. backchain progress_tail.
 apply IH to TypeOfE1. backchain progress_head.
 apply IH to TypeOfE1. backchain progress_unfold.
 apply IH to TypeOfE1. apply IH to TypeOfE2. backchain progress_app.

  backchain progress_letrec.
 apply IH to TypeOfE1. backchain progress_fix.

 apply IH to TypeOfE1. backchain progress_try.
 apply IH to TypeOfE1. backchain progress_raise.




Theorem preservation : forall E E' T, {typeOf E T} -> {step E E'} -> {typeOf E' T}.
induction on 2. intros TypeOf Main. Step : case Main.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). ToCut : inst Arg2_1 with n1 = EE. cut ToCut with Arg1_2. search.
 Arg1_1 : case TypeOf(keep). Cutting : assert ({typeOf (fix (abs R1)) T1}). ToCut : inst Arg1_2 with n1 = (fix (abs R1)). cut ToCut with Cutting.
 search.
 Arg1_1 : case TypeOf(keep). search.
 Arg1_1 : case TypeOf(keep). search.
 Arg1_1 : case TypeOf(keep). Arg2_1 : case Arg1_1(keep). search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf2 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf2 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 TypeOf1 : case TypeOf. apply IH to TypeOf1 Step. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf2. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf2. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.
 case Step. TypeOf1 : case TypeOf. case TypeOf1. search.



Theorem type_soundness : forall E E' T, {typeOf E T} -> {nstep E E'} -> progresses E'. 

induction on 2. intros Main NStep. Step1 : case NStep. 

backchain progress. 

TypeOfE2: apply preservation to Main Step1. backchain IH with E = E2.

Welcome to Abella 2.0.2
Abella < Specification "foralll".
Reading specification "foralll"

Abella < Theorem canonical_form_all : 
forall E U1, {typeOf E (all U1)} -> {value E} -> (exists Arg1, E = absT Arg1).

============================
 forall E U1, {typeOf E (all U1)} -> {value E} ->
   (exists Arg1, E = absT Arg1)

canonical_form_all < intros Main Value.

Variables: E U1
Main : {typeOf E (all U1)}
Value : {value E}
============================
 exists Arg1, E = absT Arg1

canonical_form_all < case Main.
Subgoal 1:

Variables: U1 R2
Value : {value (absT R2)}
H1 : {typeOf (R2 n1) (U1 n1)}
============================
 exists Arg1, absT R2 = absT Arg1

Subgoal 2 is:
 exists Arg1, appT E1 X = absT Arg1

canonical_form_all < case Value.
Subgoal 1:

Variables: U1 R2
H1 : {typeOf (R2 n1) (U1 n1)}
============================
 exists Arg1, absT R2 = absT Arg1

Subgoal 2 is:
 exists Arg1, appT E1 X = absT Arg1

canonical_form_all < search.
Subgoal 2:

Variables: U1 R E1 X
Value : {value (appT E1 X)}
H1 : R X = all U1
H2 : {typeOf E1 (all R)}
============================
 exists Arg1, appT E1 X = absT Arg1

canonical_form_all < case Value.
Proof completed.

Abella < Define progresses : term -> prop by 
progresses E := {value E};
progresses E := exists E', {step E E'}.

Abella < Theorem progress_absT : 
forall R1 T, {typeOf (absT R1) T} -> progresses (absT R1).

============================
 forall R1 T, {typeOf (absT R1) T} -> progresses (absT R1)

progress_absT < search.
Proof completed.

Abella < Theorem progress_appT : 
forall E1 T2 T, {typeOf (appT E1 T2) T} -> progresses E1 ->
  progresses (appT E1 T2).

============================
 forall E1 T2 T, {typeOf (appT E1 T2) T} -> progresses E1 ->
   progresses (appT E1 T2)

progress_appT < intros Main PrgsE1.

Variables: E1 T2 T
Main : {typeOf (appT E1 T2) T}
PrgsE1 : progresses E1
============================
 progresses (appT E1 T2)

progress_appT < case TypeOfE1 : Main.

Variables: E1 T2 R
PrgsE1 : progresses E1
TypeOfE1 : {typeOf E1 (all R)}
============================
 progresses (appT E1 T2)

progress_appT < case ProgressClause : PrgsE1.
Subgoal 1:

Variables: E1 T2 R
TypeOfE1 : {typeOf E1 (all R)}
ProgressClause : {value E1}
============================
 progresses (appT E1 T2)

Subgoal 2 is:
 progresses (appT E1 T2)

progress_appT < apply Canonical : canonical_form_all to TypeOfE1 ProgressClause.
Subgoal 1:

Variables: T2 R Arg1
TypeOfE1 : {typeOf (absT Arg1) (all R)}
ProgressClause : {value (absT Arg1)}
============================
 progresses (appT (absT Arg1) T2)

Subgoal 2 is:
 progresses (appT E1 T2)

progress_appT < search.
Subgoal 2:

Variables: E1 T2 R E'
TypeOfE1 : {typeOf E1 (all R)}
ProgressClause : {step E1 E'}
============================
 progresses (appT E1 T2)

progress_appT < search.
Proof completed.

Abella < Theorem progress : 
forall E T, {typeOf E T} -> progresses E.

============================
 forall E T, {typeOf E T} -> progresses E

progress < induction on 1.

IH : forall E T, {typeOf E T}* -> progresses E
============================
 forall E T, {typeOf E T}@ -> progresses E

progress < intros Main.

Variables: E T
IH : forall E T, {typeOf E T}* -> progresses E
Main : {typeOf E T}@
============================
 progresses E

progress < case TypeOfE1 : Main.
Subgoal 1:

Variables: R R2
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf (R2 n1) (R n1)}*
============================
 progresses (absT R2)

Subgoal 2 is:
 progresses (appT E1 X)

progress < backchain progress_absT.
Subgoal 2:

Variables: R E1 X
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (all R)}*
============================
 progresses (appT E1 X)

progress < apply IH to TypeOfE1.
Subgoal 2:

Variables: R E1 X
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (all R)}*
H1 : progresses E1
============================
 progresses (appT E1 X)

progress < backchain progress_appT.
Proof completed.

Abella < Theorem preservation : 
forall E E' T, {typeOf E T} -> {step E E'} -> {typeOf E' T}.

============================
 forall E E' T, {typeOf E T} -> {step E E'} -> {typeOf E' T}

preservation < induction on 2.

IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
============================
 forall E E' T, {typeOf E T} -> {step E E'}@ -> {typeOf E' T}

preservation < intros TypeOf Main.

Variables: E E' T
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf E T}
Main : {step E E'}@
============================
 {typeOf E' T}

preservation < case Step : Main.
Subgoal 1:

Variables: T X R2
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf (appT (absT R2) X) T}
============================
 {typeOf (R2 X) T}

Subgoal 2 is:
 {typeOf (appT E1' T2) T}

preservation < case Arg1_1 : TypeOf (keep).
Subgoal 1:

Variables: X R2 R
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf (appT (absT R2) X) (R X)}
Arg1_1 : {typeOf (absT R2) (all R)}
============================
 {typeOf (R2 X) (R X)}

Subgoal 2 is:
 {typeOf (appT E1' T2) T}

preservation < case Arg2_1 : Arg1_1 (keep).
Subgoal 1:

Variables: X R2 R
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf (appT (absT R2) X) (R X)}
Arg1_1 : {typeOf (absT R2) (all R)}
Arg2_1 : {typeOf (R2 n1) (R n1)}
============================
 {typeOf (R2 X) (R X)}

Subgoal 2 is:
 {typeOf (appT E1' T2) T}

preservation < inst Arg2_1 with n1 = X.
Subgoal 1:

Variables: X R2 R
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf (appT (absT R2) X) (R X)}
Arg1_1 : {typeOf (absT R2) (all R)}
Arg2_1 : {typeOf (R2 n1) (R n1)}
H1 : {typeOf (R2 X) (R X)}
============================
 {typeOf (R2 X) (R X)}

Subgoal 2 is:
 {typeOf (appT E1' T2) T}

preservation < search.
Subgoal 2:

Variables: T E1' E1 T2
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
TypeOf : {typeOf (appT E1 T2) T}
Step : {step E1 E1'}*
============================
 {typeOf (appT E1' T2) T}

preservation < case TypeOf1 : TypeOf.
Subgoal 2:

Variables: E1' E1 T2 R
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (all R)}
============================
 {typeOf (appT E1' T2) (R T2)}

preservation < apply IH to TypeOf1 Step.
Subgoal 2:

Variables: E1' E1 T2 R
IH : forall E E' T, {typeOf E T} -> {step E E'}* -> {typeOf E' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (all R)}
H1 : {typeOf E1' (all R)}
============================
 {typeOf (appT E1' T2) (R T2)}

preservation < search.
Proof completed.

Abella < Theorem type_soundness : 
forall E E' T, {typeOf E T} -> {nstep E E'} -> progresses E'.

============================
 forall E E' T, {typeOf E T} -> {nstep E E'} -> progresses E'

type_soundness < induction on 2.

IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
============================
 forall E E' T, {typeOf E T} -> {nstep E E'}@ -> progresses E'

type_soundness < intros Main NStep.

Variables: E E' T
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
NStep : {nstep E E'}@
============================
 progresses E'

type_soundness < case Step1 : NStep.
Subgoal 1:

Variables: E' T
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E' T}
============================
 progresses E'

Subgoal 2 is:
 progresses E'

type_soundness < backchain progress.
Subgoal 2:

Variables: E E' T E2
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
Step1 : {step E E2}*
Step2 : {nstep E2 E'}*
============================
 progresses E'

type_soundness < apply TypeOfE2 : preservation to Main Step1.
Subgoal 2:

Variables: E E' T E2
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
Step1 : {step E E2}*
Step2 : {nstep E2 E'}*
TypeOfE2 : {typeOf E2 T}
============================
 progresses E'

type_soundness < backchain IH with E = E2.
Proof completed.

Abella < Goodbye.
